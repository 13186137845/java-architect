# 并发编程的基础

## 并发编程的核心问题

​     在我看了， 并发编程领域可以抽象成***三个核心问题: 分工、同步和互斥***

​	 在现实世界中做饭。

## 分工

​	所谓分工，就是把一个完整的任务拆分成若个个小任务。经典的分工模式: 生产者 -  消费者。

​	类似显示中一个软件系统开发，把一个软件系统划分为多个模块，每个模块又切分成多个功能点，最后按照功能点把任务分配给开发人员。

## 协作

​	分工好了之后就是具体的执行。在项目执行过程中，任务直接是又依赖的，一个任务结束后，依赖它的后续任务就可以开工了，后续工作怎么知道可以开工了呢？这个就是靠沟通协助了，这是一项很重要的工作。

​	在并发编程领域里的同步，主要指的就是线程之间的协作，本质上和现实生活中的协助没区别，不过是***一个线程执行完成一个任务后，如果通知执行后续任务的线程开工***而已。

​	协作异步是和分工相关的。Java SDK并发包里的Executor、Fork/Join、Future本质上都是分工方法，但同时也能解决线程协作的问题。例如Future可以发起一个异步调用，当主线程通过get()方法获取结果时，主线程就会等待，当异步执行的结果返回时，get()方法就自动返回了。主线程与异步线程之间的协作，Future工具类已经帮我们解决了。除此之外，Java SDK里提供的CountDownLatch、CyclicBarrier、Phaser、Exchanger也都是用来解决线程协作问题的。

​	不过还有很多场景，是需要程序员自己来处理线程之间的协作的。

​	工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题: 当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。例如，在生产者 - 消费这模型里，也有类似的描述，"当队列满时，生产者线程需要等待，当队列不满时，生产者线程需要被唤醒执行；当队列为空时，消费者线程等待，当队列不空时，消费者线程需要被唤醒执行。"

​	在Java并发编程领域，解决协作问题的核心技术时管程，上面提到的所有线程协作技术底层都是利用管程解决的。管程时一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决互斥问题。也可以说，管程时解决并发编程的万能钥匙。

​	管程是解决并发编程的万能钥匙，Java SDK提供的并发工具类是具体的实现，我们了解SDK工具类的使用场景，这样就能大大的提高我们的工作效率。

## 互斥

​	分工、协作主要强调的是性能，但并发程序还有一部分是关于正确性的，用专业术语叫"线程安全"。

​	并发程序里，当多个线程同时访问一个同一个共享变量的时候，结果是不确定的。不确定的，就意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要源头是可见性问题、有序性问题和原子性问题。为了解决这三个问题，Java语言引入了内存模型，内存模型体提供了一些列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥。

​	互斥，指的是同一时刻只允许一个线程访问共享变量。

​	实现互斥的核心技术就是锁，Java语言里synchronized、SDK里的各种Lock都能解决互斥问题，虽然锁可以解决线程安全问题，但是同时也带来了性能问题，那如何保证线程安全性的同时又尽量提高性能呢？Java为我们提供了很多种锁，我们可以在特定的场景中使用特定的锁，这样可以使得我们的程序性能经可能的提高。

​	除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面Java提供了ThreadLocal和final关键字，还有一种Copy-on-write的模式。

​	使用锁除了要注意性能问题外，还需要注意死锁问题。

​	![并发编程全景图之思维导图](./images/fxh.png)





